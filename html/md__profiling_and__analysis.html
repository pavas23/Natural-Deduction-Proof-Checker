<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.5"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Natural Deduction Proof Checker: Profiling and Analysis</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Natural Deduction Proof Checker
   </div>
  </td>
    <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <span id="MSearchSelect"                onmouseover="return searchBox.OnSearchSelectShow()"                onmouseout="return searchBox.OnSearchSelectHide()">&#160;</span>
          <input type="text" id="MSearchField" value="" placeholder="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.svg" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.5 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(document).ready(function(){initNavTree('md__profiling_and__analysis.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Profiling and Analysis </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="autotoc_md23"></a>
Test Cases</h1>
<h3><a class="anchor" id="autotoc_md24"></a>
Test Case 1</h3>
<blockquote class="doxtable">
<p >&zwj;<br  />
 (((p&gt;q)&gt;r)^s)/P <br  />
 (p&gt;q)/P <br  />
 s/P <br  />
 ((p&gt;q)&gt;r)/^e1/1 <br  />
 p/P <br  />
 q/&gt;e/2/5 <br  />
 ~r/P <br  />
 ~(p&gt;q)/MT/4/7 <br  />
 (s^p)/^i/3/5 <br  />
 (s+r)/+i1/3 <br  />
 <br  />
</p>
<p ></p>
</blockquote>
<h3><a class="anchor" id="autotoc_md25"></a>
Test Case 2</h3>
<blockquote class="doxtable">
<p >&zwj;<br  />
 ((a&gt;b)^(d+f))/P <br  />
 ~(a^(s&gt;r))/P <br  />
 ((a&gt;b)+d)/P <br  />
 (a&gt;b)/^e1/1 <br  />
 (((a&gt;b)+d)+~w)/+i1/3 <br  />
 ((a&gt;b)&gt;~(s+f))/P <br  />
 ~(s+f)/&gt;e/6/4 <br  />
 (~(s+f)+~(a&gt;f))/+i1/7 <br  />
 (d+f)/^e2/1 <br  />
 ((d+f)^~(s+f))/^i/9/7 <br  />
 ~b/P <br  />
 ~a/MT/4/11 <br  />
 ((a^f)&gt;(g+j))/P <br  />
 ~(g+j)/P <br  />
 ~(a^f)/MT/13/14 <br  />
 ((d+f)&gt;(e^g))+(d+f))/+i2/9 <br  />
 ((a&gt;(b^c))^((h+f)&gt;(d+~z)))/P <br  />
 (a&gt;(b^c))/^e1/17 <br  />
 ((h+f)&gt;(d+~z))/^e2/17 <br  />
 (~b^((h+f)&gt;(d+~z)))/^i/11/19 <br  />
 <br  />
</p>
<p ></p>
</blockquote>
<h3><a class="anchor" id="autotoc_md26"></a>
Test Case 3</h3>
<blockquote class="doxtable">
<p >&zwj;<br  />
 ((a&gt;b)^(d&gt;(e^(g+h))))/P <br  />
 (a&gt;b)/^e1/1 <br  />
 (d&gt;(e^(g+h)))/^e2/1 <br  />
 a/P <br  />
 b/&gt;e/2/4 <br  />
 d/P <br  />
 (e^(g+h))/&gt;e/3/6 <br  />
 (g+h)/^e2/7 <br  />
 e/^e1/7 <br  />
 ~b/P <br  />
 ~a/MT/2/10 <br  />
 ((e^(g+h))^e)/^i/9/8 <br  />
 <br  />
</p>
<p ></p>
</blockquote>
<h3><a class="anchor" id="autotoc_md27"></a>
Test Case 4</h3>
<blockquote class="doxtable">
<p >&zwj;<br  />
 (((a&gt;b)&gt;(d+f))^((e+g)&gt;(r+(f&gt;(r^v)))))/P <br  />
 ((a&gt;b)&gt;(d+f))/^e1/1 <br  />
 ((e+g)&gt;(r+(f&gt;(r^v))))/^e2/1 <br  />
 (a&gt;b)/P <br  />
 (d+f)/&gt;e/2/4 <br  />
 ~b/P <br  />
 ~a/MT/4/6 <br  />
 (e+g)/P <br  />
 (r+(f&gt;(r^v)))/&gt;e/3/8 <br  />
 (a^(b^(f^(x+z))))/P <br  />
 (b^(f^(x+z)))/^e2/10 <br  />
 (f^(x+z))/^e2/11 <br  />
 ((f^(x+z))+(d+~a))/+i1/12 <br  />
 (~a^~b)/^i/7/6 <br  />
 (e+g)/P <br  />
 (r+(f&gt;(r^v)))/&gt;e/3/15 <br  />
 ((e+g)^(~a^~b))/^i/8/14 <br  />
 (s&gt;(f&gt;(g&gt;(k&gt;(q&gt;(i&gt;(y^(a&gt;(c+(x^(a+(d&gt;s))))))))))))/P <br  />
 s/P <br  />
 (f&gt;(g&gt;(k&gt;(q&gt;(i&gt;(y^(a&gt;(c+(x^(a+(d&gt;s)))))))))))/&gt;e/18/19 <br  />
 f/P <br  />
 (g&gt;(k&gt;(q&gt;(i&gt;(y^(a&gt;(c+(x^(a+(d&gt;s))))))))))/&gt;e/20/21 <br  />
 g/P <br  />
 (k&gt;(q&gt;(i&gt;(y^(a&gt;(c+(x^(a+(d&gt;s)))))))))/&gt;e/22/23 <br  />
 k/P <br  />
 (q&gt;(i&gt;(y^(a&gt;(c+(x^(a+(d&gt;s))))))))/&gt;e/24/25 <br  />
 q/P <br  />
 (i&gt;(y^(a&gt;(c+(x^(a+(d&gt;s)))))))/&gt;e/26/27 <br  />
 i/P <br  />
 (y^(a&gt;(c+(x^(a+(d&gt;s))))))/&gt;e/28/29 <br  />
 (a&gt;(c+(x^(a+(d&gt;s)))))/^e2/30 <br  />
 a/P <br  />
 (c+(x^(a+(d&gt;s))))/&gt;e/31/32 <br  />
 ((c+(x^(a+(d&gt;s))))+q)/+i1/33 <br  />
 (s+f)/+i1/19 <br  />
 <br  />
</p>
<p ></p>
</blockquote>
<h1><a class="anchor" id="autotoc_md28"></a>
Tools Used</h1>
<h3><a class="anchor" id="autotoc_md29"></a>
Gprof</h3>
<blockquote class="doxtable">
<p >&zwj; Gprof is a profiling program which collects and arranges statistics on your programs. Basically, it looks into each of your functions and inserts code at the head and tail of each one to collect timing information (actually, I don't believe it checks each time the function is run, but rather collects statistically significant samples). Then, when you run your program normally (that means with any std and file i/o you would normally have), it creates gmon.out, raw data which the gprof program turns into profiling statistics. At run-time, timing values are obtained by statistical sampling. Sampling is done by probing the target program's program counter at regular intervals using operating system interrupts. The resulting data is not exact, rather a statistical approximation. The amount of error is usually more than one sampling period. If a value is n times the sampling period, the expected error in the value is the square root of n sampling periods. A typical sampling period is 0.01 second (10 milliseconds) or 0.001 second (1 ms) or in other words 100 or 1000 samples per second of CPU running time.</p>
<p ></p>
</blockquote>
<h3><a class="anchor" id="autotoc_md30"></a>
Callgrind</h3>
<blockquote class="doxtable">
<p >&zwj; Callgrind is a Valgrind tool for profiling programs. The collected data consists of the number of instructions executed on a run, their relationship to source lines, and call relationship among functions together with call counts. It uses the processor emulation of Valgrind to run the executable, and catches all memory accesses, which are used to drive a cache simulator. The program does not need to be recompiled, it can use shared libraries and plugins, and the profile measurement doesn't influence the memory access behaviour. The trace includes the number of instruction/data memory accesses and 1st/2nd level cache misses, and relates it to source lines and functions of the run program. A disadvantage is the slowdown involved in the processor emulation, around 50 times slower. For graphical visualization of the data that is collected by Callgrind, KCachegrind application is used. Callgrind includes functions that are native to C/C++ in its analysis. If one of them appears in the highest positions of the left panel, it may be the case to try to use a different function or data structure that performs a similar task in a more efficient way. Most of the time, however, our functions are the ones in most of the top positions in the list.</p>
<p ></p>
</blockquote>
<h3><a class="anchor" id="autotoc_md31"></a>
Memcheck</h3>
<blockquote class="doxtable">
<p >&zwj; Memcheck tracks all memory reads, writes, allocations, and deallocations in a C or C++ program. The tool can detect many different memory errors. For instance, it detects reads or writes before or after allocated memory blocks. It warns about the use of (partially) undefined values in conditional code or passing such values to system calls. It will also notify you about bad or double deallocation of memory blocks. A memory leak occurs in C++ when you allocate memory dynamically and never give it back. Memcheck can detect this and submit a report back to us. This helps us optimise memory usage of a code. For a small, short-lived program that runs and immediately exits, leaks are quite harmless, but for a project of larger size and/or longevity, a repeated small leak can eventually add up. Memcheck reports summaries about leaked and dubious blocks. For each such block, it will also tell you where the block was allocated. This should help you figure out why the pointer to it has been lost. In general, you should attempt to ensure your programs do not have any leaked or dubious blocks at exit. The precise area of memory in which Memcheck searches for pointers is: all naturally-aligned 4- byte words for which all A bits indicate addressibility and all V bits indicated that the stored value is actually valid.</p>
<p ></p>
</blockquote>
<h3><a class="anchor" id="autotoc_md32"></a>
Massif</h3>
<blockquote class="doxtable">
<p >&zwj; Massif is a heap profiler. It measures how much heap memory your program uses. This includes both the useful space, and the extra bytes allocated for book-keeping and alignment purposes. It can also measure the size of your program's stack(s), although it does not do so by default. Also, there are certain space leaks that aren't detected by traditional leak-checkers, such as Memcheck's. That's because the memory isn't ever actually lost &ndash; a pointer remains to it &ndash; but it's not in use. Programs that have leaks like this can unnecessarily increase the amount of memory they are using over time. Massif can help identify these leaks. Importantly, Massif tells you not only how much heap memory your program is using, it also gives very detailed information that indicates which parts of your program are responsible for allocating the heap memory. Heap profiler such as Massif is useful to help you reduce the amount of memory your program uses.</p>
<p ></p>
</blockquote>
<h1><a class="anchor" id="autotoc_md33"></a>
Commands Used (Ubuntu Terminal)</h1>
<h3><a class="anchor" id="autotoc_md34"></a>
Gprof:</h3>
<div class="fragment"><div class="line">1. g++ -pg Functions.cpp</div>
<div class="line">2. ./a.out</div>
<div class="line">3. gprof a.out</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md35"></a>
Callgrind:</h3>
<div class="fragment"><div class="line">1. valgrind --tool=callgrind ./a.out</div>
<div class="line">2. callgrind_annotate callgrind.out.%p</div>
<div class="line">3. kcachegrind callgrind.out.%p</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md36"></a>
Memcheck:</h3>
<div class="fragment"><div class="line">1. valgrind --tool=memcheck –leak-check=yes -s ./a.out</div>
<div class="line">2. valgrind --tool=memcheck –xtree-leak=yes ./a.out</div>
<div class="line">3. callgrind_annotate xtleak.kcg.%p</div>
</div><!-- fragment --><h3><a class="anchor" id="autotoc_md37"></a>
Massif:</h3>
<div class="fragment"><div class="line">1. valgrind --tool=massif ./a.out</div>
<div class="line">2. ms_print massif.out.%p</div>
<div class="line">3. massif-visualizer massif.out.%p</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md38"></a>
What We Understood From Different Tools</h1>
<h3><a class="anchor" id="autotoc_md39"></a>
Gprof:</h3>
<p ><img src="/Test/TestCase2/gprof/gprof4.png" alt="gprof-img" height="800px" width="1000px" class="inline"/><br  />
 <img src="/Test/TestCase2/gprof/gprof5.png" alt="gprof-img" height="800px" width="1000px" class="inline"/></p>
<blockquote class="doxtable">
<p >&zwj;The call graph shows how much time was spent in each function and its children. From this information, you can find functions that, while they themselves may not have used much time, called other functions that did use unusual amounts of time. In each entry, the primary line is the one that starts with an index number in square brackets. The end of this line says which function the entry is for. The preceding lines in the entry describe the callers of this function and the following lines describe its . The entries are sorted by time spent in the function and its subroutines. </p>
</blockquote>
<p><img src="/Test/TestCase2/gprof/gprof3.png" alt="gprof-img" height="800px" width="1000px" class="inline"/></p>
<blockquote class="doxtable">
<p >&zwj;The flat profile shows the total amount of time your program spent executing each function. The functions are sorted by first by decreasing run-time spent in them, then by decreasing number of calls, then alphabetically by name. The functions 'mcount' and 'profil' are part of the profiling aparatus and appear in every flat profile; their time gives a measure of the amount of overhead due to profiling. Just before the column headers, a statement appears indicating how much time each sample counted as. This sampling period estimates the margin of error in each of the time figures. A time figure that is not much larger than this is not reliable. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md40"></a>
Callgrind:</h3>
<p ><img src="/Test/TestCase2/callgrind/cg3.png" alt="gprof-img" height="800px" width="1000px" class="inline"/><br  />
 <img src="/Test/TestCase2/callgrind/callgraph.jpg" alt="gprof-img" height="800px" width="1000px" class="inline"/><br  />
 <img src="/Test/TestCase2/callgrind/cg4.png" alt="gprof-img" height="800px" width="1000px" class="inline"/></p>
<blockquote class="doxtable">
<p >&zwj;The percentages in call graphs always show the time spent in some given function while the selected function was active, ie. the time both functions could be found on the call stack during runtime of the program. This works both in callee direction and caller direction. This graph shows us the direction of function calls with focus on “parent” functions calling other sub functions. According to test cases it also shows us how many times a function calls the other function and how much time they both were running together. The call graph view shows a graph built up around the currently selected function, which is the node centered on the grey-blended pyramid in the background. Each node represents a function, and each edge represents calls. Cost shown per function is the cost spent while that function and the selected function are running. Suppose a function C called both from A and B; in the call-graph of A, cost of node C only gives the cost when called from A, not any cost while called from B. For cycles, blue call arrows indicate that this is an artificial call added for correct drawing which actually never happened. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md41"></a>
Memcheck:</h3>
<p ><img src="/Test/TestCase3/memcheck/mmc2.png" alt="gprof-img" height="800px" width="1000px" class="inline"/><br  />
 <img src="/Test/TestCase3/memcheck/mmc1.png" alt="gprof-img" height="800px" width="1000px" class="inline"/></p>
<blockquote class="doxtable">
<p >&zwj;Since our program has memory leaks, such an output is coming. Our ultimate goal is to optimise our program in such a way that the output becomes 0 bytes in 0 blocks. Blocks of statically allocated memory, those available in the stack of the process, will be available as long as the program runs, but only in the specific execution context of each moment. Anyway, even if internally Valgrind distinguishes 9 different types of memory leaks, the generated output report will only include 4 main categories:</p><ul>
<li>Still Reachable: Covers cases 1 and 2 (for the BBB blocks)</li>
<li>Directly Lost: Covers case 3 (for the BBB blocks)</li>
<li>Indirectly Lost: Covers cases 4 and 9 (for the BBB blocks)</li>
<li>Possibly Lost: Covers cases 5, 6, 7 and 8 (for the BBB blocks)<br  />
</li>
</ul>
<p >Directly and Indirectly Lost leaks are also referred as Definitely Lost leaks. So According to the following cases we can analyse what parts of our codes are losing memory and thus optimise accordingly for a smoother running code.<br  />
 Resources: <a href="https://aleksander.es/data/valgrind-memcheck.pdf">https://aleksander.es/data/valgrind-memcheck.pdf</a> </p>
</blockquote>
<p><img src="/Test/TestCase3/memcheck/mmc3.png" alt="gprof-img" height="400px" width="800px" class="inline"/><br  />
</p>
<blockquote class="doxtable">
<p >&zwj;The increase or decrease for all events above will also be output in the file to provide the delta (increase or decrease) between 2 successive leak searches. For example, iRB is the increase of the RB event, dPBk is the decrease of PBk event. The values for the increase and decrease events will be zero for the first leak search done. </p>
</blockquote>
<h3><a class="anchor" id="autotoc_md42"></a>
Massif:</h3>
<p ><img src="/Test/TestCase3/massif/graph.jpg" alt="gprof-img" height="800px" width="1000px" class="inline"/><br  />
 <img src="/Test/TestCase2/massif/msf2.png" alt="gprof-img" height="800px" width="1000px" class="inline"/><br  />
 <img src="/Test/TestCase2/massif/msf4.png" alt="gprof-img" height="800px" width="1000px" class="inline"/><br  />
 <img src="/Test/TestCase2/massif/graph.jpg" alt="gprof-img" height="800px" width="1000px" class="inline"/></p>
<blockquote class="doxtable">
<p >&zwj;First part of ms_print's output contains a preamble which just states how the program, Massif and ms_print were each invoked. The next part is the graph that shows how memory consumption occurred as the program executed. By default, Massif uses "instructions executed" as the unit of time. For very short-run programs such as the example, most of the executed instructions involve the loading and dynamic linking of the program. The execution of main (and thus the heap allocations) only occur at the very end. For a short-running program like this, we can use the &ndash;time-unit=B option to specify that we want the time unit to instead be the number of bytes allocated/deallocated on the heap and stack(s). The graph is followed by the detailed information for each snapshot. The final detailed snapshot shows how the heap looked at termination. The 00.00% entry represents the code locations for which memory was allocated and then freed </p>
</blockquote>
<blockquote class="doxtable">
<p >&zwj;All resources including profiling tools output files and the screenshots of their running are added as the part of the zip file uploaded for submission </p>
</blockquote>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.5 </li>
  </ul>
</div>
</body>
</html>
